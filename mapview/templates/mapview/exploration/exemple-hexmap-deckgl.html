<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hex Map 3D - √âchelle Quartier</title>
    
    <!-- Mapbox GL CSS -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
    
    <!-- Tailwind pour l'interface -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: system-ui, -apple-system, sans-serif;
        }
        
        /* Container pour la carte - PREND TOUTE LA PAGE */
        #map-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        /* Panneau de contr√¥le qui flotte au-dessus */
        .panneau-controle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(17, 25, 40, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 24px;
            width: 340px;
            max-height: 85vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        
        .panneau-controle h2 {
            color: white;
            font-size: 20px;
            font-weight: bold;
            margin: 0 0 20px 0;
        }
        
        .panneau-controle label {
            color: #94A3B8;
            font-size: 12px;
            display: block;
            margin-bottom: 6px;
        }
        
        .panneau-controle input[type="range"] {
            width: 100%;
            margin-bottom: 15px;
        }
        
        .panneau-controle button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 15px;
            transition: transform 0.2s;
        }
        
        .panneau-controle button:hover {
            transform: translateY(-2px);
        }
        
        .panneau-controle select {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            margin-bottom: 15px;
        }
        
        .section-title {
            color: white;
            font-size: 14px;
            font-weight: bold;
            margin: 20px 0 10px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 15px;
        }
        
        .section-title:first-of-type {
            border-top: none;
            padding-top: 0;
            margin-top: 0;
        }
        
        .stat-box {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .stat-label {
            color: #94A3B8;
            font-size: 11px;
            margin-bottom: 4px;
        }
        
        .stat-value {
            color: white;
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- Container pour la carte Deck.gl -->
    <div id="map-container"></div>
    
    <!-- Panneau de contr√¥le -->
    <div class="panneau-controle">
        <h2>üó∫Ô∏è Hex Map 3D</h2>
        
        <!-- Bouton g√©n√©rer -->
        <button id="btn-generer" onclick="app.genererDonnees()">
            ‚ú® G√©n√©rer des points
        </button>
        
        <!-- Configuration zone -->
        <div class="section-title">üìç Zone g√©ographique</div>
        <label>Quartier:</label>
        <select id="select-zone" onchange="app.changerZone(this.value)">
            <option value="villeurbanne_grattes_ciel">Villeurbanne - Gratte-ciels</option>
            <option value="lyon_part_dieu">Lyon - Part-Dieu</option>
            <option value="paris_defense">Paris - La D√©fense</option>
            <option value="lyon_confluence">Lyon - Confluence</option>
        </select>
        
        <label>Nombre de points: <span id="nb-points-label">300</span></label>
        <input type="range" id="nb-points" min="50" max="1000" step="50" value="300" 
               oninput="document.getElementById('nb-points-label').textContent = this.value">
        
        <!-- Configuration hexagones -->
        <div class="section-title">‚¨° Configuration Hexagones</div>
        
        <label>Rayon hexagone: <span id="rayon-label">5</span>m</label>
        <input type="range" id="rayon-hex" min="1" max="10" step="0.5" value="5"
               oninput="app.mettreAJourRayon(this.value)">
        
        <label>Hauteur max: <span id="elevation-label">3</span>m</label>
        <input type="range" id="elevation-hex" min="1" max="5" step="0.5" value="3"
               oninput="app.mettreAJourElevation(this.value)">
        
        <label>Opacit√©: <span id="opacite-label">80</span>%</label>
        <input type="range" id="opacite-hex" min="0" max="100" step="5" value="80"
               oninput="app.mettreAJourOpacite(this.value)">
        
        <label>Palette de couleurs:</label>
        <select id="select-palette" onchange="app.changerPaletteCouleurs(this.value)">
            <option value="bleu_rouge">Bleu ‚Üí Rouge</option>
            <option value="jaune_rouge">Jaune ‚Üí Rouge</option>
            <option value="vert_rouge">Vert ‚Üí Rouge</option>
            <option value="violet_orange">Violet ‚Üí Orange</option>
            <option value="bleu_vert">Bleu ‚Üí Vert</option>
        </select>
        
        <!-- Style de carte -->
        <div class="section-title">üé® Style de carte</div>
        <label>Style de fond:</label>
        <select id="select-style" onchange="app.changerStyleCarte(this.value)">
            <option value="dark">Sombre (Dark)</option>
            <option value="light">Clair (Light)</option>
            <option value="streets">Rues (Streets)</option>
            <option value="satellite">Satellite</option>
        </select>
        
        <!-- Statistiques -->
        <div class="section-title">üìä Statistiques</div>
        <div class="stat-box">
            <div class="stat-label">Points g√©n√©r√©s</div>
            <div class="stat-value" id="stat-points">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Hexagones estim√©s</div>
            <div class="stat-value" id="stat-hexagones">0</div>
        </div>
    </div>

    <!-- Mapbox GL JS -->
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    
    <!-- Deck.gl -->
    <script src="https://unpkg.com/deck.gl@8.9.0/dist.min.js"></script>

    <script>
    (function() {
        'use strict';
        
        // ============================================================
        // CONFIGURATION GLOBALE - VARIABLES DJANGO
        // ============================================================
        // Ces variables peuvent √™tre facilement remplac√©es par des valeurs
        // venant de Django via template tags : {{ zone_latitude }}
        
        /**
         * Configuration des diff√©rentes zones g√©ographiques disponibles
         * 
         * DJANGO: Ces donn√©es peuvent venir de :
         * - Un mod√®le Django "Zone" avec latitude, longitude, zoom
         * - Une API REST qui renvoie les zones disponibles
         * - Un fichier de configuration settings.py
         * 
         * Format pour Django template:
         * const CONFIGURATION_ZONES = {{ zones_json|safe }};
         */
        const CONFIGURATION_ZONES = {
            // Gratte-ciels de Villeurbanne (√©chelle quartier)
            villeurbanne_grattes_ciel: {
                nom: 'Villeurbanne - Gratte-ciels',
                latitude: 45.7681,        // DJANGO: {{ zone.latitude }}
                longitude: 4.8796,        // DJANGO: {{ zone.longitude }}
                rayonKm: 0.3,             // Zone de 300m de rayon
                zoom: 16,                 // Zoom tr√®s proche pour voir les b√¢timents
                descriptionDjango: 'Quartier des gratte-ciels, immeubles Bauhaus ann√©es 30'
            },
            
            // Part-Dieu Lyon (quartier d'affaires)
            lyon_part_dieu: {
                nom: 'Lyon - Part-Dieu',
                latitude: 45.7603,
                longitude: 4.8577,
                rayonKm: 0.4,
                zoom: 15,
                descriptionDjango: 'Quartier d\'affaires avec tour Part-Dieu'
            },
            
            // La D√©fense Paris
            paris_defense: {
                nom: 'Paris - La D√©fense',
                latitude: 48.8915,
                longitude: 2.2380,
                rayonKm: 0.5,
                zoom: 15,
                descriptionDjango: 'Quartier d\'affaires avec gratte-ciels'
            },
            
            // Confluence Lyon
            lyon_confluence: {
                nom: 'Lyon - Confluence',
                latitude: 45.7362,
                longitude: 4.8161,
                rayonKm: 0.4,
                zoom: 15,
                descriptionDjango: 'Quartier moderne avec nouveaux immeubles'
            }
        };
        
        /**
         * Configuration des styles de carte disponibles
         * 
         * DJANGO: Peut venir d'un choix utilisateur stock√© en base
         * ou d'une configuration par d√©faut dans settings.py
         */
        const STYLES_CARTE_DISPONIBLES = {
            dark: {
                nom: 'Sombre',
                url: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
                descriptionDjango: 'Style sombre pour visualisation moderne'
            },
            light: {
                nom: 'Clair',
                url: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
                descriptionDjango: 'Style clair pour impression et pr√©sentation'
            },
            streets: {
                nom: 'Rues',
                url: 'https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json',
                descriptionDjango: 'Style avec d√©tails des rues'
            },
            satellite: {
                nom: 'Satellite',
                url: 'https://basemaps.cartocdn.com/gl/dark-matter-nolabels-gl-style/style.json',
                descriptionDjango: 'Vue satellite r√©elle (utilise fond sombre en attendant)'
            }
        };
        
        /**
         * Palettes de couleurs disponibles pour les hexagones
         * Chaque palette a un nom et un tableau de couleurs RGB
         * 
         * DJANGO: Ces palettes peuvent venir :
         * - D'un mod√®le "PaletteCouleur" avec nom et couleurs en JSON
         * - De cat√©gories de donn√©es (trafic = rouge, pollution = vert, etc.)
         * - Des pr√©f√©rences utilisateur
         * 
         * Format RGB : [Rouge, Vert, Bleu] avec valeurs de 0 √† 255
         */
        const PALETTES_COULEURS_DISPONIBLES = {
            // Palette 1 : Bleu ‚Üí Rose ‚Üí Rouge (inspir√©e de l'image)
            bleu_rouge: {
                nom: 'Bleu ‚Üí Rouge',
                couleurs: [
                    [26, 51, 83],        // Bleu tr√®s fonc√© (base)
                    [38, 76, 124],       // Bleu fonc√©
                    [87, 117, 144],      // Bleu moyen
                    [135, 169, 199],     // Bleu clair
                    [255, 133, 133],     // Rose clair
                    [255, 107, 107],     // Rose vif
                    [255, 71, 87]        // Rouge intense
                ],
                descriptionDjango: 'Palette froide vers chaude, id√©ale pour activit√©'
            },
            
            // Palette 2 : Jaune ‚Üí Orange ‚Üí Rouge (type carte de chaleur)
            jaune_rouge: {
                nom: 'Jaune ‚Üí Rouge',
                couleurs: [
                    [255, 255, 178],     // Jaune tr√®s clair (base)
                    [254, 217, 118],     // Jaune clair
                    [254, 178, 76],      // Orange clair
                    [253, 141, 60],      // Orange
                    [252, 78, 42],       // Orange-rouge
                    [227, 26, 28],       // Rouge vif
                    [177, 0, 38]         // Rouge fonc√©
                ],
                descriptionDjango: 'Carte de chaleur classique, universelle'
            },
            
            // Palette 3 : Vert ‚Üí Jaune ‚Üí Rouge (type pollution/alerte)
            vert_rouge: {
                nom: 'Vert ‚Üí Rouge',
                couleurs: [
                    [26, 152, 80],       // Vert fonc√© (bon)
                    [102, 189, 99],      // Vert moyen
                    [166, 217, 106],     // Vert clair
                    [255, 255, 191],     // Jaune clair (neutre)
                    [253, 174, 97],      // Orange clair
                    [244, 109, 67],      // Orange-rouge
                    [215, 48, 39]        // Rouge (alerte)
                ],
                descriptionDjango: 'Code couleur alerte, pollution, qualit√©'
            },
            
            // Palette 4 : Violet ‚Üí Rose ‚Üí Orange (type coucher de soleil)
            violet_orange: {
                nom: 'Violet ‚Üí Orange',
                couleurs: [
                    [94, 79, 162],       // Violet fonc√©
                    [158, 154, 200],     // Violet clair
                    [188, 189, 220],     // Mauve
                    [253, 184, 199],     // Rose clair
                    [254, 153, 139],     // Saumon
                    [254, 109, 67],      // Orange
                    [240, 59, 32]        // Orange-rouge vif
                ],
                descriptionDjango: 'Palette artistique, coucher de soleil'
            },
            
            // Palette 5 : Bleu ‚Üí Cyan ‚Üí Vert (type oc√©an/eau)
            bleu_vert: {
                nom: 'Bleu ‚Üí Vert',
                couleurs: [
                    [8, 48, 107],        // Bleu marine fonc√©
                    [33, 102, 172],      // Bleu
                    [67, 147, 195],      // Bleu clair
                    [146, 197, 222],     // Cyan clair
                    [209, 229, 240],     // Cyan tr√®s clair
                    [178, 226, 226],     // Turquoise
                    [102, 194, 164]      // Vert d'eau
                ],
                descriptionDjango: 'Th√®me eau, oc√©an, fra√Æcheur'
            }
        };
        
        // DJANGO EXEMPLE: const PALETTES = {{ palettes_json|safe }};
        
        
        // ============================================================
        // CLASSE GENERATEUR DE POINTS
        // G√©n√®re des points g√©ographiques al√©atoires √† l'√©chelle d'un quartier
        // ============================================================
        class GenerateurPointsQuartier {
            
            /**
             * Constructeur du g√©n√©rateur
             */
            constructor() {
                // Zone g√©ographique actuellement s√©lectionn√©e
                this.zoneActuelle = CONFIGURATION_ZONES.villeurbanne_grattes_ciel;
            }
            
            /**
             * Change la zone g√©ographique s√©lectionn√©e
             * 
             * DJANGO: Cette m√©thode sera appel√©e avec {{ zone_id }} du template
             * 
             * @param {string} codeZone - Code de la zone (ex: 'villeurbanne_grattes_ciel')
             */
            changerZone(codeZone) {
                if (CONFIGURATION_ZONES[codeZone]) {
                    this.zoneActuelle = CONFIGURATION_ZONES[codeZone];
                    console.log(`Zone chang√©e vers: ${this.zoneActuelle.nom}`);
                }
            }
            
            /**
             * G√©n√®re des points en clusters pour simuler l'activit√© dans un quartier
             * √Ä l'√©chelle d'un quartier, les clusters repr√©sentent :
             * - Des b√¢timents avec beaucoup d'activit√©
             * - Des zones de passage (rues commer√ßantes)
             * - Des points d'int√©r√™t (commerces, services)
             * 
             * DJANGO: Cette m√©thode peut recevoir des donn√©es r√©elles depuis :
             * - Une API qui renvoie des positions GPS r√©elles
             * - Une table "PointActivite" avec latitude, longitude, valeur
             * - Des donn√©es de capteurs IoT dans le quartier
             * 
             * @param {number} nombrePointsTotal - Nombre total de points √† g√©n√©rer
             * @returns {Array} - Tableau de points [{longitude, latitude, valeur}]
             */
            genererPointsEnClusters(nombrePointsTotal) {
                const pointsGeneres = [];
                
                // Cr√©er 8 √† 12 clusters (simule 8-12 b√¢timents avec activit√©)
                const nombreClusters = Math.floor(Math.random() * 5) + 8;
                const pointsParCluster = Math.floor(nombrePointsTotal / nombreClusters);
                
                console.log(`G√©n√©ration de ${nombreClusters} clusters avec ~${pointsParCluster} points chacun`);
                
                // G√©n√©rer chaque cluster (repr√©sente un b√¢timent ou zone)
                for (let indexCluster = 0; indexCluster < nombreClusters; indexCluster++) {
                    
                    // Position du centre du cluster (centre d'un b√¢timent)
                    const centreCluster = this.genererPointDansZone(
                        this.zoneActuelle.latitude,
                        this.zoneActuelle.longitude,
                        this.zoneActuelle.rayonKm
                    );
                    
                    // Intensit√© du cluster (certains b√¢timents ont plus d'activit√©)
                    const intensiteCluster = Math.random();
                    
                    // G√©n√©rer des points autour de ce centre
                    for (let indexPoint = 0; indexPoint < pointsParCluster; indexPoint++) {
                        
                        // Point al√©atoire tr√®s proche du centre (dans le b√¢timent)
                        // Rayon de 20m maximum pour rester dans un b√¢timent
                        const point = this.genererPointDansZone(
                            centreCluster.latitude,
                            centreCluster.longitude,
                            0.02  // 20 m√®tres de rayon en km
                        );
                        
                        // Calculer la distance au centre du cluster
                        const distanceAuCentre = this.calculerDistanceNormalisee(
                            point.latitude,
                            point.longitude,
                            centreCluster.latitude,
                            centreCluster.longitude
                        );
                        
                        // Valeur du point (plus proche du centre = valeur plus √©lev√©e)
                        // Multipli√©e par l'intensit√© du cluster
                        const valeurBase = (1 - distanceAuCentre) * 100;
                        point.valeur = Math.max(1, Math.floor(valeurBase * intensiteCluster));
                        
                        pointsGeneres.push(point);
                    }
                }
                
                console.log(`${pointsGeneres.length} points g√©n√©r√©s au total`);
                return pointsGeneres;
            }
            
            /**
             * G√©n√®re un point al√©atoire dans une zone circulaire
             * Utilise une distribution uniforme pour r√©partir les points
             * 
             * @param {number} latitudeCentre - Latitude du centre de la zone
             * @param {number} longitudeCentre - Longitude du centre de la zone
             * @param {number} rayonKm - Rayon de la zone en kilom√®tres
             * @returns {Object} - Point avec {latitude, longitude}
             */
            genererPointDansZone(latitudeCentre, longitudeCentre, rayonKm) {
                // Convertir le rayon en degr√©s (approximation)
                // 1 degr√© de latitude ‚âà 111 km
                const rayonDegres = rayonKm / 111;
                
                // G√©n√©rer un angle al√©atoire (direction)
                const angle = Math.random() * 2 * Math.PI;
                
                // G√©n√©rer une distance al√©atoire avec distribution uniforme
                // On utilise sqrt pour avoir une r√©partition homog√®ne sur la surface
                const distance = Math.sqrt(Math.random()) * rayonDegres;
                
                // Calculer les d√©calages en latitude et longitude
                const deltaLatitude = distance * Math.cos(angle);
                
                // La longitude n√©cessite une correction car les m√©ridiens se rapprochent
                // plus on s'√©loigne de l'√©quateur
                const deltaLongitude = distance * Math.sin(angle) / 
                    Math.cos(latitudeCentre * Math.PI / 180);
                
                return {
                    latitude: latitudeCentre + deltaLatitude,
                    longitude: longitudeCentre + deltaLongitude
                };
            }
            
            /**
             * Calcule la distance normalis√©e entre deux points (0 √† 1)
             * Utile pour calculer l'intensit√© en fonction de la proximit√©
             * 
             * @param {number} lat1 - Latitude du premier point
             * @param {number} lon1 - Longitude du premier point
             * @param {number} lat2 - Latitude du deuxi√®me point
             * @param {number} lon2 - Longitude du deuxi√®me point
             * @returns {number} - Distance normalis√©e entre 0 et 1
             */
            calculerDistanceNormalisee(lat1, lon1, lat2, lon2) {
                const deltaX = lat2 - lat1;
                const deltaY = lon2 - lon1;
                return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            }
        }
        
        
        // ============================================================
        // CLASSE APPLICATION
        // G√®re toute l'application avec Deck.gl
        // ============================================================
        class ApplicationHexMap {
            
            /**
             * Constructeur de l'application
             */
            constructor() {
                console.log('=== Initialisation de l\'application HexMap ===');
                
                // G√©n√©rateur de points pour le quartier
                this.generateur = new GenerateurPointsQuartier();
                
                // Donn√©es actuelles (points affich√©s)
                this.donneesPoints = [];
                
                // Configuration des hexagones
                // DJANGO: Ces valeurs peuvent venir de settings ou d'un mod√®le ConfigurationHexagones
                this.configurationHexagones = {
                    rayon: 5,              // Rayon en m√®tres (1 √† 10m)
                    elevationMax: 3,       // √âl√©vation maximale en m√®tres (1 √† 5m)
                    opacite: 0.8           // Opacit√© (0 √† 1)
                };
                
                // Palette de couleurs actuellement s√©lectionn√©e
                // DJANGO: Peut venir des pr√©f√©rences utilisateur
                this.paletteCouleursActuelle = 'bleu_rouge';
                
                // Style de carte actuel
                this.styleCarteActuel = 'dark';
                
                // Instance Deck.gl
                this.instanceDeckGL = null;
                
                // Initialiser l'application
                this.initialiser();
            }
            
            /**
             * Initialise l'application
             * Cr√©e la carte et charge les donn√©es initiales
             */
            initialiser() {
                console.log('Cr√©ation de la carte...');
                
                // Cr√©er la carte Deck.gl
                this.creerCarte();
                
                // G√©n√©rer des donn√©es initiales
                console.log('G√©n√©ration des donn√©es initiales...');
                this.genererDonnees();
            }
            
            /**
             * Cr√©e la carte Deck.gl avec la vue initiale
             * Configure la position, le zoom et le style
             */
            creerCarte() {
                const zone = this.generateur.zoneActuelle;
                const style = STYLES_CARTE_DISPONIBLES[this.styleCarteActuel];
                
                console.log(`Cr√©ation de la carte sur: ${zone.nom}`);
                console.log(`Style: ${style.nom}`);
                
                // Cr√©er l'instance Deck.gl
                this.instanceDeckGL = new window.deck.DeckGL({
                    // √âl√©ment HTML o√π afficher la carte
                    container: 'map-container',
                    
                    // Configuration de la vue initiale (position de la cam√©ra)
                    initialViewState: {
                        longitude: zone.longitude,    // Position Est-Ouest
                        latitude: zone.latitude,      // Position Nord-Sud
                        zoom: zone.zoom,              // Niveau de zoom (16 = √©chelle quartier)
                        pitch: 45,                    // Angle de vue (45¬∞ pour effet 3D)
                        bearing: 0                    // Rotation de la carte (0¬∞ = Nord en haut)
                    },
                    
                    // Activer les contr√¥les utilisateur
                    controller: true,  // Permet de zoomer, d√©placer, pivoter la carte
                    
                    // Style de la carte de fond
                    mapStyle: style.url,
                    
                    // Couches de visualisation (vide au d√©part, sera rempli apr√®s)
                    layers: []
                });
                
                console.log('Carte cr√©√©e avec succ√®s');
            }
            
            /**
             * G√©n√®re des donn√©es et met √† jour la visualisation
             * 
             * DJANGO: Cette m√©thode sera remplac√©e par un appel AJAX/Fetch pour r√©cup√©rer
             * les vraies donn√©es depuis une API Django :
             * 
             * async genererDonnees() {
             *     const response = await fetch('/api/points-quartier/');
             *     const data = await response.json();
             *     this.donneesPoints = data.points;
             *     this.mettreAJourCouche();
             * }
             */
            genererDonnees() {
                console.log('=== G√©n√©ration de nouvelles donn√©es ===');
                
                // R√©cup√©rer le nombre de points demand√© par l'utilisateur
                const nombrePointsDemandes = parseInt(
                    document.getElementById('nb-points').value
                );
                
                console.log(`Nombre de points demand√©s: ${nombrePointsDemandes}`);
                
                // G√©n√©rer les points via le g√©n√©rateur
                this.donneesPoints = this.generateur.genererPointsEnClusters(
                    nombrePointsDemandes
                );
                
                // Mettre √† jour la visualisation avec les nouvelles donn√©es
                this.mettreAJourCouche();
                
                // Mettre √† jour les statistiques affich√©es
                this.mettreAJourStatistiques();
                
                console.log('Donn√©es g√©n√©r√©es et affich√©es');
            }
            
            /**
             * Met √† jour la couche hexagonale 3D sur la carte
             * C'est ici que la magie op√®re : transformation des points en hexagones
             */
            mettreAJourCouche() {
                console.log('Mise √† jour de la couche hexagonale...');
                
                // R√©cup√©rer la palette de couleurs actuellement s√©lectionn√©e
                const paletteSelectionnee = PALETTES_COULEURS_DISPONIBLES[this.paletteCouleursActuelle];
                
                console.log(`Utilisation de la palette: ${paletteSelectionnee.nom}`);
                
                // Cr√©er la couche hexagonale 3D avec Deck.gl
                const coucheHexagones3D = new window.deck.HexagonLayer({
                    // Identifiant unique de la couche
                    id: 'hexagones-3d-quartier',
                    
                    // === DONN√âES ===
                    // Les points √† agr√©ger en hexagones
                    data: this.donneesPoints,
                    
                    // Fonction pour extraire la position de chaque point
                    // Retourne [longitude, latitude] pour chaque point
                    getPosition: point => [point.longitude, point.latitude],
                    
                    // Fonction pour extraire le poids de chaque point (pour l'√©l√©vation)
                    getElevationWeight: point => point.valeur,
                    
                    // === CONFIGURATION SPATIALE ===
                    // Rayon de chaque hexagone en M√àTRES (1 √† 10m pour √©chelle quartier)
                    radius: this.configurationHexagones.rayon,
                    
                    // Facteur d'√©chelle pour l'√©l√©vation (hauteur des hexagones)
                    // elevationScale transforme les valeurs en hauteur r√©elle
                    elevationScale: this.configurationHexagones.elevationMax / 100,
                    
                    // === ACTIVATION 3D ===
                    // Activer l'extrusion 3D (sinon ce serait des hexagones plats)
                    extruded: true,
                    
                    // === STYLE VISUEL ===
                    // Opacit√© globale de la couche
                    opacity: this.configurationHexagones.opacite,
                    
                    // Palette de couleurs (utilise la palette s√©lectionn√©e)
                    // Format: array de [R, G, B] pour chaque niveau
                    colorRange: paletteSelectionnee.couleurs,
                    
                    // === AGR√âGATION DES DONN√âES ===
                    // Comment agr√©ger l'√©l√©vation : somme de tous les points dans l'hexagone
                    elevationAggregation: 'SUM',
                    
                    // Comment agr√©ger la couleur : moyenne des valeurs
                    colorAggregation: 'MEAN',
                    
                    // Couverture : 0.9 = 90% de la surface hexagonale remplie
                    // (laisse un petit espace entre les hexagones)
                    coverage: 0.9,
                    
                    // === INTERACTION ===
                    // Rendre la couche cliquable/survolable
                    pickable: true,
                    
                    // Activer le highlight automatique au survol
                    autoHighlight: true,
                    
                    // Couleur du highlight (blanc semi-transparent)
                    highlightColor: [255, 255, 255, 100]
                });
                
                // Mettre √† jour les couches affich√©es dans Deck.gl
                this.instanceDeckGL.setProps({
                    layers: [coucheHexagones3D]
                });
                
                console.log(`Couche mise √† jour avec ${this.donneesPoints.length} points`);
            }
            
            /**
             * Change la zone g√©ographique et met √† jour la vue
             * Avec animation fluide de transition
             * 
             * @param {string} codeZone - Code de la nouvelle zone
             */
            changerZone(codeZone) {
                console.log(`=== Changement de zone vers: ${codeZone} ===`);
                
                // Changer la zone dans le g√©n√©rateur
                this.generateur.changerZone(codeZone);
                
                const nouvelleZone = this.generateur.zoneActuelle;
                
                // Animer la transition de cam√©ra vers la nouvelle zone
                this.instanceDeckGL.setProps({
                    initialViewState: {
                        longitude: nouvelleZone.longitude,
                        latitude: nouvelleZone.latitude,
                        zoom: nouvelleZone.zoom,
                        pitch: 45,
                        bearing: 0,
                        transitionDuration: 1000,  // Animation de 1 seconde
                        transitionInterpolator: new window.deck.FlyToInterpolator()
                    }
                });
                
                // G√©n√©rer de nouvelles donn√©es pour cette zone
                this.genererDonnees();
                
                console.log(`Zone chang√©e: ${nouvelleZone.nom}`);
            }
            
            /**
             * Met √† jour le rayon des hexagones
             * 
             * DJANGO: Cette valeur peut √™tre stock√©e dans les pr√©f√©rences utilisateur
             * ou dans un mod√®le de configuration
             * 
             * @param {number} nouveauRayonMetres - Nouveau rayon en m√®tres (1 √† 10)
             */
            mettreAJourRayon(nouveauRayonMetres) {
                const rayon = parseFloat(nouveauRayonMetres);
                this.configurationHexagones.rayon = rayon;
                
                // Mettre √† jour l'affichage du label
                document.getElementById('rayon-label').textContent = rayon;
                
                // Recalculer la couche avec le nouveau rayon
                this.mettreAJourCouche();
                
                console.log(`Rayon hexagones mis √† jour: ${rayon}m`);
            }
            
            /**
             * Met √† jour l'√©l√©vation maximale des hexagones
             * 
             * @param {number} nouvelleElevationMetres - Nouvelle √©l√©vation en m√®tres (1 √† 5m)
             */
            mettreAJourElevation(nouvelleElevationMetres) {
                const elevation = parseFloat(nouvelleElevationMetres);
                this.configurationHexagones.elevationMax = elevation;
                
                // Mettre √† jour l'affichage (avec 1 d√©cimale si n√©cessaire)
                document.getElementById('elevation-label').textContent = elevation;
                
                // Recalculer la couche
                this.mettreAJourCouche();
                
                console.log(`√âl√©vation max mise √† jour: ${elevation}m`);
            }
            
            /**
             * Met √† jour l'opacit√© des hexagones
             * 
             * @param {number} nouvelleOpacitePourcent - Nouvelle opacit√© (0 √† 100)
             */
            mettreAJourOpacite(nouvelleOpacitePourcent) {
                const opacite = parseInt(nouvelleOpacitePourcent) / 100;
                this.configurationHexagones.opacite = opacite;
                
                // Mettre √† jour l'affichage
                document.getElementById('opacite-label').textContent = nouvelleOpacitePourcent;
                
                // Recalculer la couche
                this.mettreAJourCouche();
                
                console.log(`Opacit√© mise √† jour: ${opacite}`);
            }
            
            /**
             * Change le style de la carte de fond
             * 
             * DJANGO: Le style peut √™tre une pr√©f√©rence utilisateur
             * stock√©e dans le profil : user.preferences.map_style
             * 
             * @param {string} codeStyle - Code du style ('dark', 'light', etc.)
             */
            changerStyleCarte(codeStyle) {
                console.log(`=== Changement de style carte: ${codeStyle} ===`);
                
                if (STYLES_CARTE_DISPONIBLES[codeStyle]) {
                    this.styleCarteActuel = codeStyle;
                    const style = STYLES_CARTE_DISPONIBLES[codeStyle];
                    
                    // Mettre √† jour le style de la carte
                    this.instanceDeckGL.setProps({
                        mapStyle: style.url
                    });
                    
                    console.log(`Style carte chang√©: ${style.nom}`);
                }
            }
            
            /**
             * Change la palette de couleurs des hexagones
             * 
             * DJANGO: La palette peut venir de :
             * - Pr√©f√©rences utilisateur : user.preferences.couleur_preference
             * - Type de donn√©es visualis√©es (trafic, pollution, chaleur, etc.)
             * - Th√®me de l'application
             * 
             * @param {string} codePalette - Code de la palette (ex: 'jaune_rouge')
             */
            changerPaletteCouleurs(codePalette) {
                console.log(`=== Changement de palette couleurs: ${codePalette} ===`);
                
                if (PALETTES_COULEURS_DISPONIBLES[codePalette]) {
                    this.paletteCouleursActuelle = codePalette;
                    const palette = PALETTES_COULEURS_DISPONIBLES[codePalette];
                    
                    // Recalculer la couche avec la nouvelle palette
                    this.mettreAJourCouche();
                    
                    console.log(`Palette chang√©e: ${palette.nom}`);
                }
            }
            
            /**
             * Met √† jour les statistiques affich√©es dans le panneau
             */
            mettreAJourStatistiques() {
                // Nombre de points
                const nombrePoints = this.donneesPoints.length;
                document.getElementById('stat-points').textContent = nombrePoints;
                
                // Estimer le nombre d'hexagones
                // Formule : aire de la zone / aire d'un hexagone
                const rayonMetres = this.configurationHexagones.rayon;
                const aireHexagone = 2.598 * rayonMetres * rayonMetres; // en m¬≤
                
                const rayonZoneMetres = this.generateur.zoneActuelle.rayonKm * 1000;
                const aireZone = Math.PI * rayonZoneMetres * rayonZoneMetres; // en m¬≤
                
                const hexagonesEstimes = Math.ceil(aireZone / aireHexagone);
                
                document.getElementById('stat-hexagones').textContent = hexagonesEstimes;
                
                console.log(`Stats - Points: ${nombrePoints}, Hexagones estim√©s: ${hexagonesEstimes}`);
            }
        }
        
        
        // ============================================================
        // D√âMARRAGE DE L'APPLICATION
        // ============================================================
        
        // Variable globale pour acc√©der √† l'app depuis les √©v√©nements HTML
        let app;
        
        // Attendre que la page soit compl√®tement charg√©e
        window.addEventListener('load', () => {
            console.log('=== Page charg√©e, d√©marrage de l\'application ===');
            
            // Cr√©er l'instance de l'application
            app = new ApplicationHexMap();
            
            // Exposer globalement pour les √©v√©nements onclick dans le HTML
            window.app = app;
            
            console.log('=== Application d√©marr√©e avec succ√®s ===');
        });
        
    })();
    </script>
</body>
</html>
